<!DOCTYPE html><html lang="en,zh-CN,default"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>游戏开发之状态机的实现与优化 | CdiajadeX's world</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">游戏开发之状态机的实现与优化</h1><a id="logo" href="/.">CdiajadeX's world</a><p class="description">way to my glory</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">游戏开发之状态机的实现与优化</h1><div class="post-meta">Mar 15, 2016<span> | </span><span class="category"><a href="/categories/Game-Development/">Game Development</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h1 id="游戏开发之状态机的实现与优化"><a href="#游戏开发之状态机的实现与优化" class="headerlink" title="游戏开发之状态机的实现与优化"></a>游戏开发之状态机的实现与优化</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>你是否还在面对乱作一团的代码束手无策？你是否仍然觉得复杂的逻辑无从下手？你是否觉得游戏AI高端得毫无头绪？本文将以一个复杂的弹窗逻辑和RPG游戏挂机AI的实现为案例，讲述状态机的概念及其写法。</p>
<p>本文分为以下部分：</p>
<ul>
<li><strong>有限状态机（finite-state machine）</strong>：对状态机一些概念的解释。</li>
<li><strong>案例对照</strong>：将一个复杂弹窗的普通写法和状态机编程两种实现进行对比。这里状态机的实现是多个if-else的最简单的状态机实现。</li>
<li><strong>有限状态机的优势</strong>：通过上面的对比总结状态机的优势。</li>
<li><strong>如何优雅地使用状态机</strong>：以游戏挂机自动刷怪的AI为例，提供状态模式的代码实现。</li>
<li><strong>状态机的使用场景</strong>：对状态机的使用做了一些扩充。</li>
<li><strong>总结</strong>：对本文内容的总结。</li>
<li><strong>参考资料</strong>：文中部分概念的来源以及扩展阅读的链接。</li>
</ul>
<p>对状态机一无所知的读者可以顺序看下去；写了不少逻辑，却依旧编不好繁复代码的，可以从<strong>案例对照</strong>开始阅读，相信可以让你对编程有个新的把握；会用状态机，却用得不优雅的读者，可以直接空降<strong>如何优雅地使用状态机</strong>，状态模式的实现在等着你钻研；会用一百种不同的方法花式写状态机的读者，可以直接去看文末的<strong>参考资料</strong>，希望对你有所帮助~</p>
<h2 id="有限状态机（finite-state-machine）"><a href="#有限状态机（finite-state-machine）" class="headerlink" title="有限状态机（finite-state machine）"></a>有限状态机（finite-state machine）</h2><p>有限状态机，又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。[1]</p>
<p>有限状态机可以将复杂的逻辑简化为有限个稳定状态，在稳定状态中判断事件。其中有限不是指有限次处理，而是有限个稳定状态，并且有限状态机是一个闭环系统，可以用有限的状态处理无尽的事务。</p>
<p>例如，灯的开关就是一个非常简单的有限状态机。它有两种状态：开或关。这两个状态的切换是通过手指的输入产生的。打开开关，产生从关到开的状态变换；关闭开关，产生从开到关的状态变换。<br><img src="./chart1.jpg" alt="light"></p>
<p>状态机由下列几部分组成：</p>
<ul>
<li><p>状态集(States)：包括现态和次态在内的一系列状态，用来描述状态机所处的状态。</p>
</li>
<li><p>事件(Event)：又被称为“条件”，当满足条件时，将会触发一个动作，或者执行一次状态的迁移。</p>
</li>
<li><p>动作(Action)：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。</p>
</li>
<li><p>转换(Transition)：通过转换函数将状态从现态迁移到次态的动作。迁移后次态变为现态。</p>
</li>
</ul>
<p>最著名的有限状态机可能是艾伦·图灵假想的设备——图灵机，他在1936年论文《关于可计算数字》中写道：这是一个预示着现代可编程计算机的机器，它们可以通过对无限长的磁带上的符号进行读写和擦除操作来进行任何逻辑运算。[2]</p>
<p>有限状态机实际上是一个有向图，由状态节点和状态转义函数组成。因此，当游戏策划交给你一个模块的流程图时，完全可以将流程图简化成一个或多个状态图，并进行实现。</p>
<h2 id="案例对照"><a href="#案例对照" class="headerlink" title="案例对照"></a>案例对照</h2><p>下面，我讲列举非状态机和状态机编程两种代码进行对比。</p>
<p>当我们写一个弹窗时，需求往往是这样：点击打开按钮，显示弹窗；点击关闭按钮，弹窗消失。这和本文一开始的电灯状态很相似，但这样一个简单的逻辑，并不需要使用复杂的状态机进行控制，我们可以直接对相应的按钮进行事件绑定。</p>
<p>example 1:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainUI.cpp init 函数内</span></span><br><span class="line"><span class="comment">//打开按钮</span></span><br><span class="line">Button *openBtn = Button::create();</span><br><span class="line">openBtn-&gt;addClickEventListener([=] (<span class="keyword">this</span>) </span><br><span class="line">&#123;</span><br><span class="line">	MyAlertDialog *dialog = MyAlertDialog::create();</span><br><span class="line">	dialog-&gt;show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyAlertDialog.cpp init 函数内</span></span><br><span class="line"><span class="comment">//关闭按钮</span></span><br><span class="line">Button *closeBtn = Button::create();</span><br><span class="line">closeBtn-&gt;addClickEventListener([=] (<span class="keyword">this</span>) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//关闭按钮在弹窗内部</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;dismiss();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但很多时候需求是复杂的，我们需要的弹窗可能是这样：弹窗开启前插入两个动画，动画间有0.5秒延迟，动画播完后1秒打开弹窗，弹窗打开后4s自动关闭或点击关闭按钮关闭，延迟2s后弹窗消失，关闭后主页产生变化。</p>
<p>我们仍不使用状态机编程，最终代码如下：</p>
<p>example 2:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainUI.cpp</span></span><br><span class="line"><span class="keyword">bool</span> MainUI::init()</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打开按钮</span></span><br><span class="line">	Button *openBtn = Button::create();</span><br><span class="line">	openBtn-&gt;addClickEventListener([=] (<span class="keyword">this</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		runActionBeforeShowDialog();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	m_dialog = MyAlertDialog::create();<span class="comment">//调整为成员变量进行控制，需在头文件中声明并在构造中置为nullptr</span></span><br><span class="line">	m_dialog-&gt;setDismissFunc(<span class="built_in">std</span>::bind(&amp;MainUI::dismissDialog, <span class="keyword">this</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动画</span></span><br><span class="line"><span class="keyword">void</span> MainUI::runActionBeforeShowDialog()</span><br><span class="line">&#123;</span><br><span class="line">	Action *action1 = SomeAction::create(<span class="number">2.0f</span>);</span><br><span class="line">	Action *action2 = OtherAction::create(<span class="number">1.5f</span>);<span class="comment">//第二个动画</span></span><br><span class="line">	</span><br><span class="line">	CallFunc *callback = CallFunc::create(<span class="built_in">std</span>::bind(&amp;MainUI::showDialog, <span class="keyword">this</span>));</span><br><span class="line">	</span><br><span class="line">	Sequence *seq = Sequence::create(action, DelayTime::create(<span class="number">0.5f</span>), action2, DelayTime::create(<span class="number">1.f</span>), callback, <span class="literal">nullptr</span>);<span class="comment">//增加延迟</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">this</span>-&gt;runAction(seq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化：把打开弹窗的代码整理成函数</span></span><br><span class="line"><span class="keyword">void</span> MainUI::showDialog()</span><br><span class="line">&#123;</span><br><span class="line">	dialog-&gt;show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MainUI::dismissDialog()</span><br><span class="line">&#123;</span><br><span class="line">	dialog-&gt;dismiss();</span><br><span class="line">	</span><br><span class="line">	...<span class="keyword">do</span> something...</span><br><span class="line">	</span><br><span class="line">	scheduleOnce(...);<span class="comment">//关闭弹窗后新的定时器操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//MyAlertDialog.cpp</span><br><span class="line">bool MyAlertDialog::init()</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	//关闭按钮</span><br><span class="line">	Button *closeBtn = Button::create();</span><br><span class="line">	closeBtn-&gt;addClickEventListener([=] (this) </span><br><span class="line">	&#123;</span><br><span class="line">		//延迟两秒关闭	</span><br><span class="line">		scheduleOnce(std::bind(&amp;MyAlertDialog::m_dismissFunc, this), 2.0f);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//延迟4s自动关闭,关闭延迟两秒程序员偷懒未做</span><br><span class="line">	scheduleOnce(std::bind(&amp;MyAlertDialog::m_dismissFunc, this), 4.0f);</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void setDismissFunc(std::function&lt;void()&gt; func)</span><br><span class="line">&#123;</span><br><span class="line">	m_dismissFunc = func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，在处理这样的逻辑时，我们已经将不同块的需求整理成了不同的状态，从弹窗打开到关闭无非经历了如下步骤：</p>
<ul>
<li>开始</li>
<li>点击打开，显示动画</li>
<li>动画结束，延迟1s，显示弹窗<ul>
<li>4s后自动开始关闭</li>
<li>点击关闭按钮直接进入关闭</li>
</ul>
</li>
<li>延迟2s，弹窗消失</li>
<li>结束，MainUI处理其他逻辑</li>
</ul>
<p>但是，由于没有引入状态机，上述代码从清晰简单的弹窗逻辑变成了充斥着回调和定时器的代码堆砌。如果此时流程中出现问题，很难迅速定位，导致整体效率的下降。</p>
<p>根据上述步骤，列出状态表：</p>
<table>
<thead>
<tr>
<th>当前状态</th>
<th>条件</th>
<th>状态转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>开始</td>
<td>点击开始按钮</td>
<td>显示动画</td>
<td></td>
</tr>
<tr>
<td>显示动画</td>
<td>1秒后自动切换</td>
<td>弹窗开</td>
<td></td>
</tr>
<tr>
<td>弹窗开</td>
<td>点击关闭或4秒后</td>
<td>弹窗关</td>
<td></td>
</tr>
<tr>
<td>弹窗关</td>
<td>2秒后</td>
<td>弹窗消失（结束）</td>
<td></td>
</tr>
</tbody>
</table>
<p>引入状态机来控制逻辑，最简单的写法如下：</p>
<p>example 3:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainUI.cpp</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> MAINUI_DIALOG_STATE = &#123;</span><br><span class="line">	READY,</span><br><span class="line">	SHOW_ANIMATION,</span><br><span class="line">	OPEN,</span><br><span class="line">	CLOSE,</span><br><span class="line">	DISMISS,<span class="comment">//调用关闭后2s，弹窗才会消失</span></span><br><span class="line">	END,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MainUI::init()</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	m_state = MAINUI_DIALOG_STATE.READY;</span><br><span class="line">	m_timeout = <span class="number">0</span>;<span class="comment">//存储时间间隔，作为延迟的判断条件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//打开按钮</span></span><br><span class="line">	Button *openBtn = Button::create();</span><br><span class="line">	openBtn-&gt;addClickEventListener([=] (<span class="keyword">this</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//runActionBeforeShowDialog();</span></span><br><span class="line">		setState(MAINUI_DIALOG_STATE.SHOW_ANIMATION);<span class="comment">//点击打开，展示动画</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	m_dialog = MyAlertDialog::create();<span class="comment">//调整为成员变量进行控制，需在头文件中声明并在构造中置为nullptr</span></span><br><span class="line">	m_dialog-&gt;setDismissFunc(<span class="built_in">std</span>::bind(&amp;MainUI::dismissDialog, <span class="keyword">this</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动画</span></span><br><span class="line"><span class="keyword">void</span> MainUI::runActionBeforeShowDialog()</span><br><span class="line">&#123;</span><br><span class="line">	Action *action1 = SomeAction::create(<span class="number">2.0f</span>);</span><br><span class="line">	Action *action2 = OtherAction::create(<span class="number">1.5f</span>);<span class="comment">//第二个动画</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//CallFunc *callback = CallFunc::create(std::bind(&amp;MainUI::showDialog, this));不再需要回调</span></span><br><span class="line">	</span><br><span class="line">	Sequence *seq = Sequence::create(action, DelayTime::create(<span class="number">0.5f</span>), action2, <span class="literal">nullptr</span>);<span class="comment">//移除回调和回调前的延迟</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">this</span>-&gt;runAction(seq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化：把打开弹窗的代码整理成函数</span></span><br><span class="line"><span class="keyword">void</span> MainUI::showDialog()</span><br><span class="line">&#123;</span><br><span class="line">	dialog-&gt;show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MainUI::dismissDialog()</span><br><span class="line">&#123;</span><br><span class="line">	setState(MAINUI_DIALOG_STATE.CLOSE);<span class="comment">//主动点关闭，状态变为CLOSE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MainUI::update(<span class="keyword">float</span> dt)</span><br><span class="line">&#123;</span><br><span class="line">	m_timeout += <span class="number">1</span>;<span class="comment">//每次update自加1</span></span><br><span class="line">	<span class="comment">//通过当前状态判断是否进入下一状态</span></span><br><span class="line">	<span class="keyword">if</span> (m_state == MAINUI_DIALOG_STATE.SHOW_ANIMATION)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">if</span> (m_timeout &gt; (<span class="number">4.f</span> + <span class="number">1.f</span>) * <span class="number">60</span>)<span class="comment">//cocos2d-x每秒60帧，此处即为1s延迟 + 4s动画时间</span></span><br><span class="line">		&#123;</span><br><span class="line">			setState(MAINUI_DIALOG_STATE.OPEN);<span class="comment">//延迟一秒，打开弹窗</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (m_state == MAINUI_DIALOG_STATE.OPEN)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_timeout &gt; <span class="number">4.f</span> * <span class="number">60</span>)<span class="comment">//4s后自动关闭</span></span><br><span class="line">		&#123;</span><br><span class="line">			setState(MAINUI_DIALOG_STATE.CLOSE)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (m_state == MAINUI_DIALOG_STATE.CLOSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_timeout &gt; <span class="number">2.f</span> * <span class="number">60</span>)<span class="comment">//2s后弹窗消失</span></span><br><span class="line">		&#123;</span><br><span class="line">			setState(MAINUI_DIALOG_STATE.DISMISS)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (m_state == MAINUI_DIALOG_STATE.DISMISS)</span><br><span class="line">	&#123;</span><br><span class="line">		setState(MAINUI_DIALOG_STATE.END)<span class="comment">//状态结束，没有延迟</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MainUI::setState(MAINUI_DIALOG_STATE state)</span><br><span class="line">&#123;</span><br><span class="line">	m_timeout = <span class="number">0</span>;<span class="comment">//进入新状态时，时间间隔清零</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (state == MAINUI_DIALOG_STATE.SHOW_ANIMATION)</span><br><span class="line">	&#123;</span><br><span class="line">		runActionBeforeShowDialog();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (state == MAINUI_DIALOG_STATE.OPEN)</span><br><span class="line">	&#123;</span><br><span class="line">		showDialog();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (state == MAINUI_DIALOG_STATE.CLOSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//do nothing</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (state == MAINUI_DIALOG_STATE.DISMISS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//do nothing</span></span><br><span class="line">		m_dialog-&gt;dismiss();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (state == MAINUI_DIALOG_STATE.END)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//状态结束</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	m_state = state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//MyAlertDialog.cpp</span><br><span class="line">bool MyAlertDialog::init()</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	//关闭按钮</span><br><span class="line">	Button *closeBtn = Button::create();</span><br><span class="line">	closeBtn-&gt;addClickEventListener([=] (this) </span><br><span class="line">	&#123;</span><br><span class="line">		//延迟两秒关闭	</span><br><span class="line">		//scheduleOnce(std::bind(&amp;MyAlertDialog::m_dismissFunc, this), 2.0f);</span><br><span class="line">		m_dismissFunc();//无需在这里处理延迟，调用函数设置关闭状态即可</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//延迟4s自动关闭,关闭延迟两秒程序员偷懒未做</span><br><span class="line">	//scheduleOnce(std::bind(&amp;MyAlertDialog::m_dismissFunc, this), 4.0f);</span><br><span class="line">	//此处延迟已统一由MainUI进行处理</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void setDismissFunc(std::function&lt;void()&gt; func)</span><br><span class="line">&#123;</span><br><span class="line">	m_dismissFunc = func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过example 2、3的对比，我们可以看出，使用状态机，不仅让代码更加清晰，而且将逻辑都放在了MainUI处理，包括弹窗的显示和消失，弹窗只关注自身内部的变化，不去对自己进行dismiss的操作，使逻辑解耦。并且在这一过程中任何一个步骤出现问题，都能很快进行定位，并直接对相应状态下的代码进行调整，不会影响其他的状态。</p>
<p>同时我们可以看到状态机的四个部分，首先在枚举中定义了所有的<strong>状态</strong>，用m_state表示现态；在update函数和按钮响应事件中设置动作触发的<strong>事件</strong>；<strong>动作</strong>触发后执行响应逻辑并通过转移函数进行状态的切换；而setState则是状态的<strong>转移函数</strong>。</p>
<h2 id="有限状态机的优势"><a href="#有限状态机的优势" class="headerlink" title="有限状态机的优势"></a>有限状态机的优势</h2><p>通过上述案例，我们可以得出有限状态机的五个优点：</p>
<ul>
<li><strong>编程快速简单</strong>。编写有限状态机的方法有很多种，并且几乎所有的实现方法都非常简单。本文中将会提供几种状态机的实现方法及其利弊。</li>
<li><strong>易于调试</strong>。将游戏逻辑分解成不同的状态，使得问题的定位和修改变得方便。</li>
<li><strong>很少的计算开销</strong>。有限状态机几乎不占用珍贵的处理器时间，因为它本质上遵守硬件编码规则，只需要对if-else进行处理。</li>
<li><strong>直觉性</strong>。在生活中，人们总是自然地把事物思考为处在一种或另一种状态。“进入状态”、“状态不佳”也是我们常见的。在编码中，将游戏逻辑分解成一系列状态并创建相应的规则去处理是非常容易的。</li>
<li><strong>灵活性</strong>。代码增删变得方便快捷。</li>
</ul>
<p>事实上，在写逻辑的时候已经潜在地使用了状态，只是没有把状态抽象出来，而是直接按流程去编写代码，使用响应、回调的方式做逻辑处理，这样使得在增删流程，后期维护时代码耦合过深，难以维护，最终不得不进行重构。而且当逻辑出现问题时，很难直接定位问题，降低了调试效率。</p>
<h2 id="如何优雅地使用状态机"><a href="#如何优雅地使用状态机" class="headerlink" title="如何优雅地使用状态机"></a>如何优雅地使用状态机</h2><p>上述给出的只是最简单的状态机，适合较少状态之间的切换.当逻辑变得庞杂的时候，if-else的逻辑将变成一场噩梦。状态的切换会让我们难以把握程序的现状。往后的扩展也会变得相当困难。</p>
<p>这里我就要向大家介绍，如何优雅地使用状态机。</p>
<p>我们在开发游戏的时候，经常会碰到游戏AI，在编写游戏AI时，我们通常会选择有限状态机。</p>
<p>一般来说，在设计角色、怪物、NPC的时候，很有可能都是继承自同一个基类，此时状态机就不宜写成上面那种格式。我们可以先将状态写成一个抽象类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> State</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~State() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Enter</span><span class="params">(Player*)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Execute</span><span class="params">(Player*)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Exit</span><span class="params">(Player*)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里预留了Enter和Exit的接口，方便做状态切换时的<strong>动作</strong>。上述三个接口都有一个Player的指针作为传参。这里我不想以简单我怪物的逻辑作为示例来讲解，现在很多RPG类的手游都提供了挂机刷怪的逻辑，点开这个设置，角色就会自动跑到附近的副本里刷怪升级，减轻玩家的负担。</p>
<p>这里我设定一个逻辑，开始挂机时，自动寻找附近副本，刷怪，刷怪需要体力值，体力过低时会自动回城休息，刷怪获得物品占满物品栏时会自动回城贩卖。达到设定要求时挂机停止。如图2所示。</p>
<p>![chart2] (./chart2.jpg)</p>
<p>根据上述条件，我们可以得出Player的类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Class Player : <span class="keyword">public</span> BaseGameEntity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	State* m_pCurrentState;</span><br><span class="line">	location m_location;<span class="comment">//当前位置</span></span><br><span class="line">	<span class="keyword">int</span> m_gold;<span class="comment">//金币数</span></span><br><span class="line">	<span class="keyword">int</span> m_exp;<span class="comment">//经验数</span></span><br><span class="line">	<span class="keyword">int</span> m_strength;<span class="comment">//体力值</span></span><br><span class="line">	<span class="keyword">int</span> m_goods;<span class="comment">//物品数</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Player(<span class="keyword">int</span> uid);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//状态转移函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ChangeState</span><span class="params">(State* newState)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Player::update()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_pCurrentState)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pCurrentState-&gt;Execute(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Player::ChangeState(State* newState)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//现态退出时的动作</span></span><br><span class="line">	m_pCurrentState-&gt;Exit(<span class="keyword">this</span>);</span><br><span class="line">	m_pCurrentState = newState;</span><br><span class="line">	<span class="comment">//次态进入时的动作</span></span><br><span class="line">	m_pCurrentState-&gt;Enter(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过图2我们可以看到，一共有四个状态：</p>
<ul>
<li>挂机：将角色移动到副本中，寻找附近的怪物击杀，获取经验和金钱，扣除体力。若经验到达设定值，则停止挂机。</li>
<li>回城休息：角色体力过低，自动移动位置到城里休息。休息完毕回到挂机状态。</li>
<li>回城贩卖：角色背包装满，回城自动贩卖，若金钱到达设定值，则停止挂机，否则回到挂机状态。</li>
<li>结束：挂机过程结束，角色回城。</li>
</ul>
<p>以挂机状态为例，实现这个状态只需要直接将State类继承过来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AutoState : <span class="keyword">public</span> State</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	AutoState() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Enter</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Execute</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Exit</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据逻辑补齐接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AutoState::Enter(Player* player)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//寻找副本</span></span><br><span class="line">	player-&gt;ChangeLocation(dungeon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AutoState::Execute(Player* player)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//认为每次执行就击杀了一个怪物</span></span><br><span class="line">	player-&gt;AddGold(<span class="number">1</span>);</span><br><span class="line">	player-&gt;AddExp(<span class="number">1</span>);</span><br><span class="line">	player-&gt;AddGoods(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	player-&gt;DecreaseStrength();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//背包装满，则回城贩卖</span></span><br><span class="line">	<span class="keyword">if</span> (player-&gt;PocketsFull())</span><br><span class="line">	&#123;</span><br><span class="line">		player-&gt;ChangeState(<span class="keyword">new</span> GoBackAndSellState());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//体力值过低，则回城休息</span></span><br><span class="line">	<span class="keyword">if</span> (player-&gt;NeedRest())</span><br><span class="line">	&#123;</span><br><span class="line">		player-&gt;ChangeState(<span class="keyword">new</span> GoBackAndRestState());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AutoState::Execute(Player* player)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span> &lt;&lt; GetNameOfEntity(player-&gt;Uid()) &lt;&lt; <span class="string">": "</span>&lt;&lt; <span class="string">"I'm leaving the dungeon!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码简单地讲述了如何使用状态模式编写一段游戏AI，上述的实现方式就是<strong>状态模式</strong>[3]。为了方便讲解，这里所列举出的状态都是比较独立的，以便于我们对状态机本身的理解和状态模式的把握。</p>
<p>通过这几段代码，和上面example 3作对比，我们可以发现新的写法丢弃了繁重的if-else结构，通过类的继承的方式来实现整个逻辑，这样不仅简化了逻辑的编写，也让我们搭建游戏框架变得更加方便。状态的增删也仅需要新建和移除状态子类即可，十分快捷。</p>
<p>当然，细心的朋友可能发现，我们在每次切换状态的时候都做了一次new的操作，在状态切换频繁的时候会消耗很多资源。这里可以具体问题具体分析，究竟是直接new，还是将子类写成单例，则需要读者根据需求自己把握了。</p>
<h2 id="状态机的使用场景"><a href="#状态机的使用场景" class="headerlink" title="状态机的使用场景"></a>状态机的使用场景</h2><p>状态机的使用场景非常广泛，除了上述在游戏中处理UI逻辑和编写游戏AI时需要使用状态机编程以外，还有很多地方会用到状态机。</p>
<p>状态机本身广泛应用于硬件控制电路设计中，比如比较经典的电梯、洗衣机的控制。</p>
<p>软件中如正则表达式[4]、词法分析，网络协议如下图所示的TCP/IP协议[5]等，可以说有限状态机是无处不在的。</p>
<p>![chart2] (./chart3.png)</p>
<p>当然，<strong>任何编程规范都不宜被滥用。</strong>在最初的时候，example 1就已经是比较合适的写法了，没有必要过度追求编程规范，反而会降低开发效率。本文中只是以一个复杂的弹窗（结算动画、中奖提示等类型）讲述状态机的优势，在实际应用场景中，游戏主逻辑、游戏大厅等具有复杂UI交互的类，都可以考虑使用状态机来进行代码编写，细分状态，保证代码的健壮性，方便以后扩展新的特性。</p>
<p>本文侧重游戏开发中的状态机，这里提到的一些使用场景在文末<strong>参考资料</strong>部分附上了链接，有兴趣的朋友可以进行深入阅读。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在游戏开发中，状态机有利于处理复杂模块的逻辑，降低耦合度，方便扩展特性。</p>
<p>简单实现的状态机会面临if-else过多所造成的难以维护的问题，而状态模式则是实现状态机的最优解法，在细节处仍有不少可优化的地方。</p>
<p>状态机应用广泛，但不宜滥用状态机。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA" title="Title" target="_blank" rel="external">有限状态机</a></p>
<p>[2] Mat Buckland, Programming Game AI by example</p>
<p>[3] <a href="http://design-patterns.readthedocs.org/zh_CN/latest/behavioral_patterns/state.html" title="Title" target="_blank" rel="external">状态模式</a></p>
<p>[4] <a href="http://qntm.org/algo" target="_blank" rel="external">Algorithm for converting a finite state machine into a regular expression</a></p>
<p>[5] <a href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm" target="_blank" rel="external">TCP Finite State Machine</a></p>
<p>##写在最后<br>本文由笔者近期工作和学习所得，上述示例代码均为直接手写，若有错漏，欢迎指出。</p>
<p>未经允许，不得转载。</p>
<p>By：陈玉潇 CdiajadeX</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://chenyuxiaodhr.github.io/zh-CN/Game-Development/ciltl1sk8000143s6eak7k4id/" data-id="ciltl1sk8000143s6eak7k4id" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Game-Development/">Game Development</a><a href="/tags/Finite-State-Machine/">Finite State Machine</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://chenyuxiaodhr.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Game-Development/">Game Development</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Game-Development/" style="font-size: 15px;">Game Development</a> <a href="/tags/Finite-State-Machine/" style="font-size: 15px;">Finite State Machine</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/zh-CN/Game-Development/ciltl1sk8000143s6eak7k4id/">游戏开发之状态机的实现与优化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">CdiajadeX's world.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>